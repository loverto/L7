module.exports = '\nprecision highp float;\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_dimension;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform float u_min;\nuniform float u_max;\nuniform vec4 u_extent;\n#define PI 3.141592653589793\n\nvoid main() {\n\n    \n      vec2 u_latrange = vec2(3.83718,53.5636);\n      float u_zoom = 7.0;\n      float u_maxzoom= 10.0;\n      vec2 epsilon = 1.0 / u_dimension;\n      vec2 u_light = vec2(0.5000, 5.8469);\n      vec4 u_accent = vec4(0.,0.,0.,1.);\n      vec4 u_highlight = vec4(1.0);\n      vec4 u_shadow = vec4(0.,0.,0.,1.);\n      float a = texture2D(u_texture,v_texCoord - epsilon)[0];\n      float b = texture2D(u_texture,v_texCoord+vec2(0,-epsilon.y))[0];\n      float c = texture2D(u_texture,v_texCoord+ vec2(epsilon.x - epsilon.y))[0];\n      float d = texture2D(u_texture,v_texCoord+ vec2(-epsilon.x,0))[0];\n      float e = texture2D(u_texture,v_texCoord)[0];\n      float f = texture2D(u_texture,v_texCoord+ vec2(epsilon.x,0))[0];\n      float g = texture2D(u_texture,v_texCoord+ vec2(-epsilon.x,epsilon.y))[0];\n      float h = texture2D(u_texture,v_texCoord+ vec2(0,epsilon.y))[0];\n      float i = texture2D(u_texture,v_texCoord+ epsilon)[0];\n      float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\n\n      vec2 deriv = vec2(\n          (c + f + f + i) - (a + d + d + g),\n          (g + h + h + i) - (a + b + b + c)\n      ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);\n      float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_texCoord.y) + u_latrange[1]));\n      float slope = atan(1.25 * length(deriv) / scaleFactor);\n      float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);\n      \n      float intensity = u_light.x;\n      float azimuth = u_light.y + PI;\n\n      float base = 1.875 - intensity * 1.75;\n      float maxValue = 0.5 * PI;\n      float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;\n\n      float accent = cos(scaledSlope);\n      // We multiply both the accent and shade color by a clamped intensity value\n      // so that intensities >= 0.5 do not additionally affect the color values\n      // while intensity values < 0.5 make the overall color more transparent.\n      vec4 accent_color = (1.0 - accent) * v_color * clamp(intensity * 2.0, 0.0, 1.0);\n      float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);\n      vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);\n      //gl_FragColor = v_color * (1.0 - shade_color.a) + shade_color;\n      gl_FragColor = v_color;\n\n}';