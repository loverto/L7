module.exports = '//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\nprecision highp float;\n#define SMOOTH(r,R) (1.0-smoothstep(R-0.01,R+0.01, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-0.01,a+0.01,x)*(1.0-smoothstep(b-0.01,b+0.01,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\nuniform float u_time;\nvarying vec2 v_texCoord;\nvarying  vec4 v_color;\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90. * u_time;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,0.01) + 0.9*gradient;\n        // return SMOOTH(l,1.);\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float x = uv.x;\n    float y = uv.y;\n    float r = sqrt( dot( d, d ) );\n   \n\n     float w = abs(uv.x)-abs(uv.y);\n     float z1 = smoothstep(-0.020,-0.012,w);\n     float z2 = smoothstep(-0.02,-0.012,-w);\n     float z3 = z1*z2 * (1.0 - step(radius,r));\n     return z3;\n}\n\nvoid main()\n{\n    vec3 finalColor;\n\tvec2 uv = v_texCoord * 2.0 - 1.0;\n    vec2 c = vec2(0.,0.);\n    finalColor = vec3( 0.3 * _cross(uv, c, 0.6) );\n    finalColor += ( circle(uv, c, 0.2, 0.01)\n                   + circle(uv, c, 0.4, 0.01) ) * blue1;\n    finalColor += (circle(uv, c, 0.6, 0.02) );\n    finalColor += movingLine(uv, c, 0.6) * v_color.xyz;\n    finalColor += circle(uv, c, 0.1, 0.01) * v_color.xyz;\n\n    float alpha = 1.0;\n    if(finalColor==vec3(0.)) alpha = 0.;\n    gl_FragColor = vec4(finalColor, alpha);\n}';