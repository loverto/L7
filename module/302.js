module.exports = 'precision mediump float;\nattribute vec4 a_color;\nattribute vec4 a_instance;\nattribute float a_size;\nuniform float u_zoom;\nuniform float u_time;\nuniform mat4 matModelViewProjection;\nuniform float segmentNumber;  \nvarying vec4 v_color;\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n    vec2 x = mix(source, target, ratio);\n    vec2 center = mix(source, target, 0.5);\n    float dSourceCenter = distance(source, center);\n    float dXCenter = distance(x, center);\n    return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n     float vertex_height = paraboloid(source, target, segmentRatio);\n    \n    return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n    );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * a_size * pow(2.0,20.0-u_zoom) / 2.0;\n  return offset;\n}\n\n\nvoid main() {\n    float visindex =mod(u_time *10.,segmentNumber);\n    mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n    vec2 source = a_instance.rg;\n    vec2 target = a_instance.ba;\n    float segmentIndex = position.x;\n    float segmentRatio = getSegmentRatio(segmentIndex);\n    float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n    \n    vec3 curr = getPos(source, target, segmentRatio);\n    vec3 next = getPos(source, target, nextSegmentRatio);\n    vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, position.y);\n    gl_Position =matModelViewProjection * vec4(vec3(curr + vec3(offset, 0.0)),1.0);\n    // float apha = 0.;\n    // if( position.x> 0. && position.x <visindex)\n    //   apha =1.0;\n    // vec3 c1 = vec3(0.929,0.972,0.917);\n    // vec3 c2 = vec3(0.062,0.325,0.603); \n   // v_color = mix(c1, c2, segmentRatio);\n    v_color = a_color;\n    \n\n}';